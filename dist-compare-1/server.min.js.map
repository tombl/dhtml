{"version":3,"file":"server.min.js","names":[],"sources":["../src/server.ts"],"sourcesContent":["import { assert, is_html, is_iterable, is_renderable, lexer, single_part_template, type Displayable } from './shared.ts'\n\ninterface PartRenderer {\n\treplace_start: number\n\treplace_end: number\n\trender: (values: unknown[]) => string | Generator<string, void, void>\n}\n\ninterface CompiledTemplate {\n\tsource: string\n\tparts: PartRenderer[]\n\textra_parts: number\n}\n\nconst WHITESPACE = /\\s/\n\nconst templates = new WeakMap<TemplateStringsArray, CompiledTemplate>()\nfunction compile_template(statics: TemplateStringsArray): CompiledTemplate {\n\tconst cached = templates.get(statics)\n\tif (cached) return cached\n\n\tconst compiled: CompiledTemplate = {\n\t\tsource: statics.join('\\0'),\n\t\tparts: [],\n\t\textra_parts: 0,\n\t}\n\tlet offset = 0\n\tlet dyn_i = 0\n\n\tlet whitespace_count = 0\n\tlet prev_state: lexer.State | undefined\n\tlet attr_name: string = ''\n\tlet attr_start: number | undefined\n\n\tfunction collapse_whitespace() {\n\t\tif (whitespace_count > 1) {\n\t\t\tcompiled.extra_parts++\n\t\t\tcompiled.parts.push({\n\t\t\t\treplace_start: offset - whitespace_count,\n\t\t\t\treplace_end: offset,\n\t\t\t\trender: () => ' ',\n\t\t\t})\n\t\t}\n\t\twhitespace_count = 0\n\t}\n\n\tfor (const [char, state] of lexer.lex(statics)) {\n\t\tif (state === lexer.ATTR_NAME) {\n\t\t\tif (prev_state !== lexer.ATTR_NAME) {\n\t\t\t\tattr_name = ''\n\t\t\t\tattr_start = offset\n\t\t\t}\n\t\t\tattr_name += char\n\t\t}\n\n\t\tif (state === lexer.DATA && WHITESPACE.test(char)) {\n\t\t\twhitespace_count++\n\t\t} else {\n\t\t\tcollapse_whitespace()\n\t\t}\n\n\t\tif (char === '\\0') {\n\t\t\tconst i = dyn_i++\n\n\t\t\tswitch (state) {\n\t\t\t\tcase lexer.DATA:\n\t\t\t\tcase lexer.COMMENT:\n\t\t\t\tcase lexer.COMMENT2:\n\t\t\t\t\tcompiled.parts.push({\n\t\t\t\t\t\treplace_start: offset,\n\t\t\t\t\t\treplace_end: offset + 1,\n\t\t\t\t\t\trender: values => render_child(values[i]),\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tcase lexer.ATTR_VALUE_UNQUOTED:\n\t\t\t\tcase lexer.ATTR_VALUE_DOUBLE_QUOTED:\n\t\t\t\tcase lexer.ATTR_VALUE_SINGLE_QUOTED:\n\t\t\t\t\tconst name = attr_name\n\t\t\t\t\tassert(attr_start !== undefined)\n\t\t\t\t\tcompiled.parts.push({\n\t\t\t\t\t\treplace_start: attr_start,\n\t\t\t\t\t\treplace_end: offset + 1 + (state === lexer.ATTR_VALUE_UNQUOTED ? 0 : 1),\n\t\t\t\t\t\trender: values => render_attribute(name, values[i]),\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tcase lexer.ATTR_NAME:\n\t\t\t\t\tcompiled.parts.push({\n\t\t\t\t\t\treplace_start: offset,\n\t\t\t\t\t\treplace_end: offset + 1,\n\t\t\t\t\t\trender: values => render_directive(values[i]),\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false, `unexpected state ${state}`)\n\t\t\t}\n\t\t}\n\n\t\tprev_state = state\n\t\toffset++\n\t}\n\tcollapse_whitespace()\n\n\tif (__DEV__) {\n\t\tlet prev_end = -1\n\t\tfor (const { replace_start, replace_end } of compiled.parts) {\n\t\t\tassert(replace_start >= prev_end)\n\t\t\tassert(replace_start < replace_end)\n\t\t\tprev_end = replace_end\n\t\t}\n\t}\n\n\ttemplates.set(statics, compiled)\n\treturn compiled\n}\n\nfunction render_directive(value: unknown) {\n\tif (value === null) return ''\n\n\tassert(typeof value === 'function')\n\t// console.log('directive returned:', value())\n\n\treturn ''\n}\n\nfunction render_attribute(name: string, value: unknown) {\n\tif (value === false || value === null || typeof value === 'function') {\n\t\treturn ''\n\t}\n\tif (value === true) return name\n\treturn `${name}=\"${escape(value)}\"`\n}\n\nfunction* render_child(value: unknown): Generator<string, void, void> {\n\tyield '<?[>'\n\n\tif (is_renderable(value)) {\n\t\ttry {\n\t\t\tvalue = value.render()\n\t\t} catch (thrown) {\n\t\t\tif (is_html(thrown)) {\n\t\t\t\tvalue = thrown\n\t\t\t} else {\n\t\t\t\tthrow thrown\n\t\t\t}\n\t\t}\n\n\t\tif (is_renderable(value)) value = single_part_template(value)\n\t}\n\n\tif (is_iterable(value)) {\n\t\tfor (const item of value) yield* render_child(item)\n\t} else if (is_html(value)) {\n\t\tconst { _statics: statics, _dynamics: dynamics } = value\n\t\tconst template = compile_template(statics)\n\n\t\tassert(\n\t\t\ttemplate.parts.length - template.extra_parts === dynamics.length,\n\t\t\t'expected the same number of dynamics as parts. do you have a ${...} in an unsupported place?',\n\t\t)\n\n\t\tlet prev_end = 0\n\t\tfor (const { replace_start, replace_end, render } of template.parts) {\n\t\t\tyield template.source.slice(prev_end, replace_start)\n\t\t\tyield* render(dynamics)\n\t\t\tprev_end = replace_end\n\t\t}\n\t\tyield template.source.slice(prev_end)\n\t} else if (value !== null) {\n\t\tyield escape(value)\n\t}\n\n\tyield '<?]>'\n}\n\nconst ESCAPE_RE = /[&<>\"']/g\nconst ESCAPE_SUBSTITUTIONS = {\n\t'&': '&amp;',\n\t'<': '&lt;',\n\t'>': '&gt;',\n\t'\"': '&quot;',\n\t\"'\": '&#39;',\n}\nfunction escape(str: unknown) {\n\treturn String(str).replace(ESCAPE_RE, c => ESCAPE_SUBSTITUTIONS[c as keyof typeof ESCAPE_SUBSTITUTIONS])\n}\n\nexport function renderToString(value: Displayable): string {\n\tlet str = ''\n\tfor (const part of render_child(value)) str += part\n\treturn str\n}\n\nexport function renderToReadableStream(value: Displayable): ReadableStream<Uint8Array> {\n\tconst iter = render_child(value)\n\treturn new ReadableStream<string>({\n\t\tpull(controller) {\n\t\t\tconst { done, value } = iter.next()\n\t\t\tif (done) {\n\t\t\t\tcontroller.close()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontroller.enqueue(value)\n\t\t},\n\t}).pipeThrough(new TextEncoderStream())\n}\n"],"mappings":"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"}