{"version":3,"file":"client.js","names":["controllers: WeakMap<Renderable, Controller>","renderable: Renderable","keys: WeakMap<Displayable & object, Key>","invalidate","callback: () => Cleanup","callback: () => void","displayable: T","key: Key","displayable: unknown","node: Node","DYNAMIC_WHOLE: RegExp","templates: WeakMap<TemplateStringsArray, CompiledTemplate>","statics: TemplateStringsArray","compiled: CompiledTemplate","node: DocumentFragment | HTMLElement | SVGElement","idx: number","data: PartData","match","parent: Node","node: Node","span: Span","span: Span","current_renderable?: Renderable","old_template?: CompiledTemplate","template_parts?: [number, Part][]","entries?: Array<{ _span: Span; _part: Part; _key: Key }>","old_value?: unknown","next: Renderable | undefined","span","node_by_part: Array<Node | Span>","child: ChildNode | null","node: Node","name: string","node: Element","cleanup: Cleanup","el: Element","value: unknown","value: string | boolean | null | undefined","type: string","listener: EventListenerOrEventListenerObject","options?: boolean | AddEventListenerOptions","parent: Node","start: Comment","node: ChildNode | null","value: Displayable","span: Span","value: unknown","current_renderable: Renderable | undefined","template: CompiledTemplate | undefined","template_parts: [number, Part][] | undefined","entries: Array<{ _span: Span; _part: Part; _key: Key }> | undefined","span","node_by_part: Array<Node | Span>","child: ChildNode | null"],"sources":["../src/client/controller.ts","../src/client/util.ts","../src/client/compiler.ts","../src/client/span.ts","../src/client/parts.ts","../src/client/root.ts"],"sourcesContent":["import type { Displayable, Renderable } from '../index.ts'\nimport { assert, is_renderable } from '../shared.ts'\nimport { type Cleanup } from './util.ts'\n\nexport type Key = string | number | bigint | boolean | symbol | object | null\n\nexport interface Controller {\n\t_mount_callbacks: (() => Cleanup)[]\n\t_unmount_callbacks: Cleanup[]\n\t_invalidate: Map<object, () => void>\n}\n\nexport const controllers: WeakMap<Renderable, Controller> = new WeakMap()\n\nexport function get_controller(renderable: Renderable): Controller {\n\tlet controller = controllers.get(renderable)\n\tif (!controller)\n\t\tcontrollers.set(\n\t\t\trenderable,\n\t\t\t(controller = {\n\t\t\t\t_mount_callbacks: [],\n\t\t\t\t_unmount_callbacks: [],\n\t\t\t\t_invalidate: new Map(),\n\t\t\t}),\n\t\t)\n\treturn controller\n}\n\nconst keys: WeakMap<Displayable & object, Key> = new WeakMap()\n\nexport function invalidate(renderable: Renderable): void {\n\tconst controller = controllers.get(renderable)\n\tassert(controller, 'the renderable has not been rendered')\n\tcontroller._invalidate.forEach(invalidate => invalidate())\n}\n\nexport function onMount(renderable: Renderable, callback: () => Cleanup): void {\n\tassert(is_renderable(renderable), 'expected a renderable')\n\tconst controller = get_controller(renderable)\n\tif (controller._invalidate.size) {\n\t\tcontroller._unmount_callbacks.push(callback())\n\t} else {\n\t\tcontroller._mount_callbacks.push(callback)\n\t}\n}\n\nexport function onUnmount(renderable: Renderable, callback: () => void): void {\n\tonMount(renderable, () => callback)\n}\n\nexport function keyed<T extends Displayable & object>(displayable: T, key: Key): T {\n\tassert(!keys.has(displayable), 'renderable already has a key')\n\tkeys.set(displayable, key)\n\treturn displayable\n}\n\nexport function get_key(displayable: unknown): unknown {\n\t// the cast is fine because getting any non-object will return null\n\treturn keys.get(displayable as object) ?? displayable\n}\n","export type Cleanup = (() => void) | void | undefined | null\n\nexport function is_element(node: Node): node is Element {\n\treturn node.nodeType === (1 satisfies typeof Node.ELEMENT_NODE)\n}\n\nexport function is_comment(node: Node): node is Comment {\n\treturn node.nodeType === (8 satisfies typeof Node.COMMENT_NODE)\n}\n\nexport function is_document_fragment(node: Node): node is DocumentFragment {\n\treturn node.nodeType === (11 satisfies typeof Node.DOCUMENT_FRAGMENT_NODE)\n}\n","import { assert, lexer } from '../shared.ts'\nimport { is_comment, is_document_fragment, is_element } from './util.ts'\n\nexport const PART_CHILD = 0\nexport const PART_DIRECTIVE = 1\nexport const PART_ATTRIBUTE = 2\nexport const PART_PROPERTY = 3\n\nexport type PartData =\n\t| [type: typeof PART_CHILD, index: number]\n\t| [type: typeof PART_DIRECTIVE]\n\t| [type: typeof PART_ATTRIBUTE, name: string]\n\t| [type: typeof PART_PROPERTY, name: string]\n\nexport interface CompiledTemplate {\n\t_content: DocumentFragment\n\t_parts: [idx: number, PartData][]\n\t_root_parts: number[]\n}\n\nexport const DYNAMIC_WHOLE: RegExp = /^dyn-\\$(\\d+)\\$$/\nconst DYNAMIC_GLOBAL = /dyn-\\$(\\d+)\\$/g\nconst FORCE_ATTRIBUTES = /-|^class$|^for$/i\nconst NEEDS_UPPERCASING = /\\$./g\n\nconst templates: WeakMap<TemplateStringsArray, CompiledTemplate> = new WeakMap()\nexport function compile_template(statics: TemplateStringsArray): CompiledTemplate {\n\tconst cached = templates.get(statics)\n\tif (cached) return cached\n\n\tconst template_element = document.createElement('template')\n\tlet next_part = 0\n\ttemplate_element.innerHTML = [...lexer.lex(statics)]\n\t\t.map(([char, state]) => {\n\t\t\tif (char === '\\0') {\n\t\t\t\tif (state === lexer.DATA) return `<!--dyn-$${next_part++}$-->`\n\t\t\t\telse return `dyn-$${next_part++}$`\n\t\t\t}\n\t\t\tif (state === lexer.ATTR_NAME && char.toLowerCase() !== char) {\n\t\t\t\treturn `$${char}`\n\t\t\t}\n\t\t\treturn char\n\t\t})\n\t\t.join('')\n\n\tnext_part = 0\n\n\tconst compiled: CompiledTemplate = {\n\t\t_content: template_element.content,\n\t\t_parts: Array(statics.length - 1),\n\t\t_root_parts: [],\n\t}\n\n\tfunction patch(node: DocumentFragment | HTMLElement | SVGElement, idx: number, data: PartData) {\n\t\tassert(next_part < compiled._parts.length, 'got more parts than expected')\n\t\tif (is_document_fragment(node)) compiled._root_parts.push(next_part)\n\t\telse if ('dynparts' in node.dataset) node.dataset.dynparts += ' ' + next_part\n\t\t// @ts-expect-error -- this assigment will cast nextPart to a string\n\t\telse node.dataset.dynparts = next_part\n\t\tcompiled._parts[next_part++] = [idx, data]\n\t}\n\n\tconst walker = document.createTreeWalker(template_element.content, 129)\n\tassert((NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT) === 129)\n\n\twhile (walker.nextNode()) {\n\t\tconst node = walker.currentNode\n\t\tif (is_comment(node)) {\n\t\t\tconst match = DYNAMIC_WHOLE.exec(node.data)\n\t\t\tif (match !== null) {\n\t\t\t\tconst parent_node = node.parentNode\n\t\t\t\tassert(parent_node !== null, 'all text nodes should have a parent node')\n\t\t\t\tassert(\n\t\t\t\t\tparent_node instanceof DocumentFragment ||\n\t\t\t\t\t\tparent_node instanceof HTMLElement ||\n\t\t\t\t\t\tparent_node instanceof SVGElement,\n\t\t\t\t)\n\n\t\t\t\t// these will become the start and end of the span:\n\t\t\t\tparent_node.insertBefore(new Text(), node)\n\t\t\t\tparent_node.insertBefore(new Text(), node.nextSibling)\n\n\t\t\t\tpatch(parent_node, parseInt(match[1]), [PART_CHILD, [...parent_node.childNodes].indexOf(node)])\n\t\t\t}\n\t\t} else {\n\t\t\tassert(is_element(node))\n\t\t\tassert(node instanceof HTMLElement || node instanceof SVGElement)\n\n\t\t\tfor (const name of node.getAttributeNames()) {\n\t\t\t\tconst value = node.getAttribute(name)\n\t\t\t\tassert(value !== null)\n\n\t\t\t\tlet match = DYNAMIC_WHOLE.exec(name)\n\t\t\t\tif (match !== null) {\n\t\t\t\t\t// directive:\n\t\t\t\t\tnode.removeAttribute(name)\n\t\t\t\t\tassert(value === '', `directives must not have values`)\n\t\t\t\t\tpatch(node, parseInt(match[1]), [PART_DIRECTIVE])\n\t\t\t\t} else {\n\t\t\t\t\t// properties:\n\t\t\t\t\tmatch = DYNAMIC_WHOLE.exec(value)\n\t\t\t\t\tconst remapped_name = name.replace(NEEDS_UPPERCASING, match => match[1].toUpperCase())\n\t\t\t\t\tif (match !== null) {\n\t\t\t\t\t\tnode.removeAttribute(name)\n\t\t\t\t\t\tif (FORCE_ATTRIBUTES.test(remapped_name)) {\n\t\t\t\t\t\t\tpatch(node, parseInt(match[1]), [PART_ATTRIBUTE, remapped_name])\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpatch(node, parseInt(match[1]), [PART_PROPERTY, remapped_name])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (remapped_name !== name) {\n\t\t\t\t\t\tassert(!node.hasAttribute(remapped_name), `duplicate attribute ${remapped_name}`)\n\t\t\t\t\t\tnode.setAttribute(remapped_name, value)\n\t\t\t\t\t\tnode.removeAttribute(name)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(\n\t\t\t\t\t\t\t!DYNAMIC_GLOBAL.test(value),\n\t\t\t\t\t\t\t`expected a whole dynamic value for ${remapped_name}, got a partial one`,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcompiled._parts.length = next_part\n\n\ttemplates.set(statics, compiled)\n\treturn compiled\n}\n","import { assert } from '../shared.ts'\n\nexport interface Span {\n\treadonly _parent: Node\n\treadonly _start: Node\n\treadonly _end: Node\n}\n\nexport function create_span(node: Node): Span {\n\tassert(node.parentNode !== null)\n\tconst start = new Text()\n\tconst end = new Text()\n\n\tnode.parentNode.insertBefore(start, node)\n\tnode.parentNode.insertBefore(end, node.nextSibling)\n\n\treturn {\n\t\t_parent: node.parentNode,\n\t\t_start: start,\n\t\t_end: end,\n\t}\n}\n\nexport function create_span_into(parent: Node): Span {\n\tconst start = new Text()\n\tconst end = new Text()\n\n\tparent.appendChild(start)\n\tparent.appendChild(end)\n\n\treturn {\n\t\t_parent: parent,\n\t\t_start: start,\n\t\t_end: end,\n\t}\n}\n\nexport function create_span_after(node: Node): Span {\n\tassert(node.parentNode !== null)\n\tconst start = new Text()\n\tconst end = new Text()\n\n\tnode.parentNode.insertBefore(end, node.nextSibling)\n\tnode.parentNode.insertBefore(start, end)\n\n\treturn {\n\t\t_parent: node.parentNode,\n\t\t_start: start,\n\t\t_end: end,\n\t}\n}\n\nexport function insert_node(span: Span, node: Node): void {\n\tspan._parent.insertBefore(node, span._end)\n}\n\nexport function extract_contents(span: Span): DocumentFragment {\n\tconst fragment = document.createDocumentFragment()\n\n\tlet node = span._start.nextSibling\n\tfor (;;) {\n\t\tassert(node)\n\t\tif (node === span._end) break\n\t\tconst next = node.nextSibling\n\t\tfragment.appendChild(node)\n\t\tnode = next\n\t}\n\n\treturn fragment\n}\n\nexport function delete_contents(span: Span): void {\n\tlet node = span._start.nextSibling\n\tfor (;;) {\n\t\tassert(node)\n\t\tif (node === span._end) break\n\t\tconst next = node.nextSibling\n\t\tspan._parent.removeChild(node)\n\t\tnode = next\n\t}\n}\n","import {\n\tassert,\n\tis_html,\n\tis_iterable,\n\tis_renderable,\n\tsingle_part_template,\n\ttype Displayable,\n\ttype Renderable,\n} from '../shared.ts'\nimport {\n\tcompile_template,\n\tPART_ATTRIBUTE,\n\tPART_CHILD,\n\tPART_DIRECTIVE,\n\tPART_PROPERTY,\n\ttype CompiledTemplate,\n} from './compiler.ts'\nimport { controllers, get_controller, get_key, type Key } from './controller.ts'\nimport { create_span_after, delete_contents, extract_contents, insert_node, type Span } from './span.ts'\nimport type { Cleanup } from './util.ts'\n\nexport type Part = (value: unknown) => void\n\nexport function create_child_part(\n\tspan: Span,\n\n\t// for when we're rendering a renderable:\n\tneeds_revalidate = true,\n\tcurrent_renderable?: Renderable,\n\n\t// for when we're rendering a template:\n\told_template?: CompiledTemplate,\n\ttemplate_parts?: [number, Part][],\n\n\t// for when we're rendering multiple values:\n\tentries?: Array<{ _span: Span; _part: Part; _key: Key }>,\n\n\t// for when we're rendering a string/single dom node:\n\t// undefined means no previous value, because a user-specified undefined is remapped to null\n\told_value?: unknown,\n): Part {\n\tfunction switch_renderable(next: Renderable | undefined) {\n\t\tif (current_renderable && current_renderable !== next) {\n\t\t\tconst controller = controllers.get(current_renderable)\n\t\t\tif (controller) {\n\t\t\t\tcontroller._invalidate.delete(switch_renderable)\n\n\t\t\t\t// If this was the last instance, call unmount callbacks\n\t\t\t\tif (!controller._invalidate.size) {\n\t\t\t\t\tcontroller._unmount_callbacks.forEach(callback => callback?.())\n\t\t\t\t\tcontroller._unmount_callbacks.length = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcurrent_renderable = next\n\t}\n\n\tfunction disconnect_root() {\n\t\tif (template_parts !== undefined) {\n\t\t\tfor (const [, part] of template_parts) part(null)\n\t\t\told_template = undefined\n\t\t\ttemplate_parts = undefined\n\t\t}\n\t}\n\n\treturn function update(value) {\n\t\tif (is_renderable(value)) {\n\t\t\tif (!needs_revalidate && value === current_renderable) return\n\t\t\tneeds_revalidate = false\n\n\t\t\tswitch_renderable(value)\n\n\t\t\tconst renderable = value\n\t\t\tconst controller = get_controller(renderable)\n\t\t\t// If this is the first mounted instance, call mount callbacks\n\t\t\tif (!controller._invalidate.size) {\n\t\t\t\tcontroller._unmount_callbacks = controller._mount_callbacks.map(callback => callback())\n\t\t\t}\n\t\t\tcontroller._invalidate.set(switch_renderable, () => {\n\t\t\t\tassert(renderable === current_renderable)\n\t\t\t\tneeds_revalidate = true\n\t\t\t\tupdate(renderable)\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tvalue = renderable.render()\n\t\t\t} catch (thrown) {\n\t\t\t\tif (is_html(thrown)) {\n\t\t\t\t\tvalue = thrown\n\t\t\t\t} else {\n\t\t\t\t\tthrow thrown\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if render returned another renderable, we want to track/cache both renderables individually.\n\t\t\t// wrap it in a nested ChildPart so that each can be tracked without ChildPart having to handle multiple renderables.\n\t\t\tif (is_renderable(value)) value = single_part_template(value)\n\t\t} else switch_renderable(undefined)\n\n\t\t// if it's undefined, swap the value for null.\n\t\t// this means if the initial value is undefined,\n\t\t// it won't conflict with old_value's default of undefined,\n\t\t// so it'll still render.\n\t\tif (value === undefined) value = null\n\n\t\t// NOTE: we're explicitly not caching/diffing the value when it's an iterable,\n\t\t// given it can yield different values but have the same identity. (e.g. arrays)\n\t\tif (is_iterable(value)) {\n\t\t\tif (!entries) {\n\t\t\t\t// we previously rendered a single value, so we need to clear it.\n\t\t\t\tdisconnect_root()\n\t\t\t\tdelete_contents(span)\n\t\t\t\tentries = []\n\t\t\t}\n\n\t\t\t// create or update a root for every item.\n\t\t\tlet i = 0\n\t\t\tlet end = span._start\n\t\t\tfor (const item of value) {\n\t\t\t\tconst key = get_key(item) as Key\n\t\t\t\tif (entries.length <= i) {\n\t\t\t\t\tconst span = create_span_after(end)\n\t\t\t\t\tentries[i] = { _span: span, _part: create_child_part(span), _key: key }\n\t\t\t\t}\n\n\t\t\t\tif (key !== undefined && entries[i]._key !== key) {\n\t\t\t\t\tfor (let j = i + 1; j < entries.length; j++) {\n\t\t\t\t\t\tconst entry1 = entries[i]\n\t\t\t\t\t\tconst entry2 = entries[j]\n\n\t\t\t\t\t\tif (entry2._key === key) {\n\t\t\t\t\t\t\t// swap the contents of the spans\n\t\t\t\t\t\t\tconst tmp_content = extract_contents(entry1._span)\n\t\t\t\t\t\t\tinsert_node(entry1._span, extract_contents(entry2._span))\n\t\t\t\t\t\t\tinsert_node(entry2._span, tmp_content)\n\n\t\t\t\t\t\t\t// swap the spans back\n\t\t\t\t\t\t\tconst tmp_span = { ...entry1._span }\n\t\t\t\t\t\t\tObject.assign(entry1._span, entry2._span)\n\t\t\t\t\t\t\tObject.assign(entry2._span, tmp_span)\n\n\t\t\t\t\t\t\t// swap the roots\n\t\t\t\t\t\t\tentries[j] = entry1\n\t\t\t\t\t\t\tentries[i] = entry2\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tentries[i]._key = key\n\t\t\t\t}\n\n\t\t\t\tentries[i]._part(item as Displayable)\n\t\t\t\tend = entries[i]._span._end\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\t// and now remove excess parts if the iterable has shrunk.\n\t\t\twhile (entries.length > i) {\n\t\t\t\tconst entry = entries.pop()\n\t\t\t\tassert(entry)\n\t\t\t\tentry._part(null)\n\t\t\t}\n\n\t\t\told_value = undefined\n\t\t\treturn\n\t\t} else if (entries) {\n\t\t\tfor (const entry of entries) entry._part(null)\n\t\t\tentries = undefined\n\t\t}\n\n\t\tif (is_html(value)) {\n\t\t\tconst { _dynamics: dynamics, _statics: statics } = value\n\t\t\tconst template = compile_template(statics)\n\n\t\t\tassert(\n\t\t\t\ttemplate._parts.length === dynamics.length,\n\t\t\t\t'expected the same number of dynamics as parts. do you have a ${...} in an unsupported place?',\n\t\t\t)\n\n\t\t\tif (old_template !== template) {\n\t\t\t\tif (template_parts !== undefined) {\n\t\t\t\t\t// scan through all the parts of the previous tree, and clear any renderables.\n\t\t\t\t\tfor (const [_idx, part] of template_parts) part(null)\n\t\t\t\t\ttemplate_parts = undefined\n\t\t\t\t}\n\n\t\t\t\told_template = template\n\n\t\t\t\tconst doc = old_template._content.cloneNode(true) as DocumentFragment\n\n\t\t\t\tconst node_by_part: Array<Node | Span> = []\n\n\t\t\t\tfor (const node of doc.querySelectorAll('[data-dynparts]')) {\n\t\t\t\t\tconst parts = node.getAttribute('data-dynparts')\n\t\t\t\t\tassert(parts)\n\t\t\t\t\tnode.removeAttribute('data-dynparts')\n\t\t\t\t\tfor (const part of parts.split(' ')) node_by_part[+part] = node\n\t\t\t\t}\n\n\t\t\t\tfor (const part of old_template._root_parts) node_by_part[part] = span\n\n\t\t\t\t// the fragment must be inserted before the parts are constructed,\n\t\t\t\t// because they need to know their final location.\n\t\t\t\t// this also ensures that custom elements are upgraded before we do things\n\t\t\t\t// to them, like setting properties or attributes.\n\t\t\t\tdelete_contents(span)\n\t\t\t\tinsert_node(span, doc)\n\n\t\t\t\ttemplate_parts = template._parts.map(([dynamic_index, [type, data]], element_index): [number, Part] => {\n\t\t\t\t\tconst node = node_by_part[element_index]\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase PART_CHILD:\n\t\t\t\t\t\t\tlet child: ChildNode | null\n\n\t\t\t\t\t\t\tif (node instanceof Node) {\n\t\t\t\t\t\t\t\tchild = node.childNodes[data]\n\t\t\t\t\t\t\t\tassert(child)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchild = node._start.nextSibling\n\t\t\t\t\t\t\t\tassert(child)\n\t\t\t\t\t\t\t\tfor (let i = 0; i < data; i++) {\n\t\t\t\t\t\t\t\t\tchild = child.nextSibling\n\t\t\t\t\t\t\t\t\tassert(child !== null, 'expected more siblings')\n\t\t\t\t\t\t\t\t\tassert(child !== node._end, 'ran out of siblings before the end')\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tassert(child.parentNode && child.previousSibling && child.nextSibling)\n\n\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\tdynamic_index,\n\t\t\t\t\t\t\t\tcreate_child_part({\n\t\t\t\t\t\t\t\t\t_parent: child.parentNode,\n\t\t\t\t\t\t\t\t\t_start: child.previousSibling,\n\t\t\t\t\t\t\t\t\t_end: child.nextSibling,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\tcase PART_DIRECTIVE:\n\t\t\t\t\t\t\tassert(node instanceof Node)\n\t\t\t\t\t\t\treturn [dynamic_index, create_directive_part(node)]\n\t\t\t\t\t\tcase PART_ATTRIBUTE:\n\t\t\t\t\t\t\tassert(node instanceof Element)\n\t\t\t\t\t\t\treturn [dynamic_index, create_attribute_part(node, data)]\n\t\t\t\t\t\tcase PART_PROPERTY:\n\t\t\t\t\t\t\tassert(node instanceof Node)\n\t\t\t\t\t\t\treturn [dynamic_index, create_property_part(node, data)]\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tassert(template_parts)\n\t\t\tfor (const [idx, part] of template_parts) part(dynamics[idx])\n\n\t\t\told_value = undefined\n\t\t\treturn\n\t\t}\n\n\t\tif (!Object.is(old_value, value)) {\n\t\t\t// if we previously rendered a tree that might contain renderables,\n\t\t\t// and the template has changed (or we're not even rendering a template anymore),\n\t\t\t// we need to clear the old renderables.\n\t\t\tdisconnect_root()\n\n\t\t\tif (old_value != null && value !== null && !(old_value instanceof Node) && !(value instanceof Node)) {\n\t\t\t\t// we previously rendered a string, and we're rendering a string again.\n\t\t\t\tassert(span._start.nextSibling?.nextSibling === span._end && span._start.nextSibling instanceof Text)\n\t\t\t\tspan._start.nextSibling.data = '' + value\n\t\t\t} else {\n\t\t\t\tdelete_contents(span)\n\t\t\t\tif (value !== null) insert_node(span, value instanceof Node ? value : new Text('' + value))\n\t\t\t}\n\n\t\t\told_value = value\n\t\t}\n\t}\n}\n\nexport function create_property_part(node: Node, name: string): Part {\n\treturn value => {\n\t\t// @ts-expect-error\n\t\tnode[name] = value\n\t}\n}\n\nexport function create_attribute_part(node: Element, name: string): Part {\n\treturn value => set_attr(node, name, value)\n}\n\nexport type Directive = (el: Element) => Cleanup\n\nexport function create_directive_part(node: Node): Part {\n\tlet cleanup: Cleanup\n\treturn fn => {\n\t\tassert(typeof fn === 'function' || fn == null)\n\t\tcleanup?.()\n\t\tcleanup = fn?.(node)\n\t}\n}\n\nfunction set_attr(el: Element, name: string, value: unknown) {\n\tif (typeof value === 'boolean') el.toggleAttribute(name, value)\n\telse if (value == null) el.removeAttribute(name)\n\t// the cast is fine because setAttribute implicitly casts the value to a string\n\telse el.setAttribute(name, value as string)\n}\n\nexport function attr_directive(name: string, value: string | boolean | null | undefined): Directive {\n\treturn el => {\n\t\tset_attr(el, name, value)\n\t\treturn () => set_attr(el, name, null)\n\t}\n}\n\nexport function on_directive(\n\ttype: string,\n\tlistener: EventListenerOrEventListenerObject,\n\toptions?: boolean | AddEventListenerOptions,\n): Directive {\n\treturn el => {\n\t\tel.addEventListener(type, listener, options)\n\t\treturn () => el.removeEventListener(type, listener, options)\n\t}\n}\n","import { assert, is_html, is_iterable, is_renderable, single_part_template, type Displayable, type Renderable } from '../shared.ts'\nimport {\n\tcompile_template,\n\tDYNAMIC_WHOLE,\n\tPART_ATTRIBUTE,\n\tPART_CHILD,\n\tPART_DIRECTIVE,\n\tPART_PROPERTY,\n\ttype CompiledTemplate,\n} from './compiler.ts'\nimport { get_key, type Key } from './controller.ts'\nimport {\n\tcreate_attribute_part,\n\tcreate_child_part,\n\tcreate_directive_part,\n\tcreate_property_part,\n\ttype Part,\n} from './parts.ts'\nimport { create_span_into, type Span } from './span.ts'\nimport { is_comment, is_element } from './util.ts'\n\nexport interface Root {\n\trender(value: Displayable): void\n}\n\nexport function createRoot(parent: Node): Root {\n\tconst span = create_span_into(parent)\n\treturn { render: create_child_part(span) }\n}\n\nfunction find_end(start: Comment): Comment | null {\n\tassert(start.data === '?[')\n\tlet depth = 1\n\tlet node: ChildNode | null = start\n\twhile ((node = node.nextSibling)) {\n\t\tif (is_comment(node)) {\n\t\t\tif (node.data === '?[') depth++\n\t\t\telse if (node.data === '?]') {\n\t\t\t\tdepth--\n\t\t\t\tif (depth === 0) return node\n\t\t\t}\n\t\t}\n\t}\n\treturn null\n}\n\nexport function hydrate(parent: Node, value: Displayable): Root {\n\tlet start\n\tfor (start of parent.childNodes) {\n\t\tif (is_comment(start) && start.data === '?[') break\n\t}\n\tassert(\n\t\tstart && is_comment(start),\n\t\t`Could not find hydration start comment. Please ensure the element contains server-side rendered output.`,\n\t)\n\n\tconst end = find_end(start)\n\tassert(end, `Could not find hydration end comment. Please ensure the element contains server-side rendered output.`)\n\n\tconst render = hydrate_child_part({ _parent: parent, _start: start, _end: end }, value)\n\trender(value)\n\treturn { render }\n}\n\nfunction hydrate_child_part(span: Span, value: unknown) {\n\tlet current_renderable: Renderable | undefined\n\tlet template: CompiledTemplate | undefined\n\tlet template_parts: [number, Part][] | undefined\n\tlet entries: Array<{ _span: Span; _part: Part; _key: Key }> | undefined\n\n\tif (is_renderable(value)) {\n\t\ttry {\n\t\t\tvalue = (current_renderable = value).render()\n\t\t} catch (thrown) {\n\t\t\tif (is_html(thrown)) {\n\t\t\t\tvalue = thrown\n\t\t\t} else {\n\t\t\t\tthrow thrown\n\t\t\t}\n\t\t}\n\n\t\tif (is_renderable(value)) value = single_part_template(value)\n\t}\n\n\tif (is_iterable(value)) {\n\t\tentries = []\n\t\tconst { _parent } = span\n\t\tlet end = span._start\n\n\t\tfor (const item of value) {\n\t\t\tconst key = get_key(item) as Key\n\n\t\t\tconst start = end.nextSibling\n\t\t\tassert(start && is_comment(start) && start.data === '?[')\n\n\t\t\tend = find_end(start)!\n\t\t\tassert(end)\n\n\t\t\tconst span: Span = { _parent, _start: start, _end: end }\n\t\t\tentries.push({ _span: span, _part: hydrate_child_part(span, item), _key: key })\n\t\t}\n\t\tassert(end.nextSibling === span._end)\n\t}\n\n\tif (is_html(value)) {\n\t\ttemplate = compile_template(value._statics)\n\n\t\tconst node_by_part: Array<Node | Span> = []\n\n\t\tconst walker = document.createTreeWalker(span._parent, 129)\n\t\tconst template_walker = document.createTreeWalker(template._content, 129)\n\t\tassert((NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT) === 129)\n\t\twalker.currentNode = span._start\n\n\t\twhile (walker.nextNode() && template_walker.nextNode()) {\n\t\t\tconst node = walker.currentNode\n\t\t\tconst template_node = template_walker.currentNode\n\t\t\tif (node === span._end) break\n\n\t\t\tif (is_comment(node) && is_comment(template_node)) {\n\t\t\t\tif (node.data === '?[') {\n\t\t\t\t\tassert(DYNAMIC_WHOLE.test(template_node.data))\n\t\t\t\t\tconst end = find_end(node)\n\t\t\t\t\tassert(end)\n\t\t\t\t\twalker.currentNode = end\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tassert(is_element(node))\n\t\t\tassert(\n\t\t\t\tnode.nodeType === template_node.nodeType,\n\t\t\t\t`Node type mismatch: ${node.nodeType} != ${template_node.nodeType}`,\n\t\t\t)\n\t\t\tassert(template_node instanceof HTMLElement || template_node instanceof SVGElement)\n\t\t\tassert(node.tagName === template_node.tagName, `Tag name mismatch: ${node.tagName} !== ${template_node.tagName}`)\n\n\t\t\tif (template_node.dataset.dynparts)\n\t\t\t\tfor (const part of template_node.dataset.dynparts.split(' ')) node_by_part[+part] = node\n\t\t}\n\n\t\tfor (const part of template._root_parts) node_by_part[part] = span\n\n\t\ttemplate_parts = template._parts.map(([dynamic_index, [type, data]], element_index): [number, Part] => {\n\t\t\tconst node = node_by_part[element_index]\n\t\t\tswitch (type) {\n\t\t\t\tcase PART_CHILD:\n\t\t\t\t\tlet child: ChildNode | null\n\n\t\t\t\t\tif (node instanceof Node) {\n\t\t\t\t\t\tchild = node.childNodes[data]\n\t\t\t\t\t\tassert(child)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild = node._start.nextSibling\n\t\t\t\t\t\tassert(child)\n\t\t\t\t\t\tfor (let i = 0; i < data; i++) {\n\t\t\t\t\t\t\tchild = child.nextSibling\n\t\t\t\t\t\t\tassert(child !== null, 'expected more siblings')\n\t\t\t\t\t\t\tassert(child !== node._end, 'ran out of siblings before the end')\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tassert(child.parentNode)\n\t\t\t\t\tassert(child.previousSibling && is_comment(child.previousSibling) && child.previousSibling.data === '?[')\n\t\t\t\t\tconst end = find_end(child.previousSibling)\n\t\t\t\t\tassert(end)\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tdynamic_index,\n\t\t\t\t\t\thydrate_child_part(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_parent: child.parentNode,\n\t\t\t\t\t\t\t\t_start: child.previousSibling,\n\t\t\t\t\t\t\t\t_end: end,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue._dynamics[dynamic_index],\n\t\t\t\t\t\t),\n\t\t\t\t\t]\n\t\t\t\tcase PART_DIRECTIVE:\n\t\t\t\t\tassert(node instanceof Node)\n\t\t\t\t\treturn [dynamic_index, create_directive_part(node)]\n\t\t\t\tcase PART_ATTRIBUTE:\n\t\t\t\t\tassert(node instanceof Element)\n\t\t\t\t\treturn [dynamic_index, create_attribute_part(node, data)]\n\t\t\t\tcase PART_PROPERTY:\n\t\t\t\t\tassert(node instanceof Node)\n\t\t\t\t\treturn [dynamic_index, create_property_part(node, data)]\n\t\t\t}\n\t\t})\n\t}\n\n\treturn create_child_part(span, true, current_renderable, template, template_parts, entries, value)\n}\n"],"mappings":"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"}