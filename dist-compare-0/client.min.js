import { b as e, f as i, d as n, e as r, c as t } from './shared.min.js'
const a = new WeakMap()
function o(e) {
	let t = a.get(e)
	return (t || a.set(e, (t = { t: [], o: [], i: new Map() })), t)
}
const s = new WeakMap()
function c(e) {
	a.get(e).i.forEach(e => e())
}
function l(e, t) {
	let n = o(e)
	n.i.size ? n.o.push(t()) : n.t.push(t)
}
function u(e, t) {
	l(e, () => t)
}
function d(e, t) {
	return (s.set(e, t), e)
}
function f(e) {
	return s.get(e) ?? e
}
function p(e) {
	return e.nodeType === 8
}
const m = /^dyn-\$(\d+)\$$/,
	h = /-|^class$|^for$/i,
	g = /\$./g,
	_ = new WeakMap()
function v(e) {
	let t = _.get(e)
	if (t) return t
	let n = document.createElement(`template`),
		r = 0
	;((n.innerHTML = [...i(e)]
		.map(([e, t]) =>
			e === `\0`
				? t === 0
					? `\x3c!--dyn-$${r++}$--\x3e`
					: `dyn-$${r++}$`
				: t === 5 && e.toLowerCase() !== e
					? `$${e}`
					: e,
		)
		.join(``)),
		(r = 0))
	let a = { u: n.content, l: Array(e.length - 1), _: [] }
	function o(e, t, n) {
		;((function (e) {
			return e.nodeType === 11
		})(e)
			? a._.push(r)
			: `dynparts` in e.dataset
				? (e.dataset.dynparts += ` ` + r)
				: (e.dataset.dynparts = r),
			(a.l[r++] = [t, n]))
	}
	let s = document.createTreeWalker(n.content, 129)
	for (; s.nextNode(); ) {
		let e = s.currentNode
		if (p(e)) {
			let t = m.exec(e.data)
			if (t !== null) {
				let n = e.parentNode
				;(n.insertBefore(new Text(), e),
					n.insertBefore(new Text(), e.nextSibling),
					o(n, parseInt(t[1]), [0, [...n.childNodes].indexOf(e)]))
			}
		} else
			for (let t of e.getAttributeNames()) {
				let n = e.getAttribute(t),
					r = m.exec(t)
				if (r !== null) (e.removeAttribute(t), o(e, parseInt(r[1]), [1]))
				else {
					r = m.exec(n)
					let i = t.replace(g, e => e[1].toUpperCase())
					r === null
						? i !== t && (e.setAttribute(i, n), e.removeAttribute(t))
						: (e.removeAttribute(t), h.test(i) ? o(e, parseInt(r[1]), [2, i]) : o(e, parseInt(r[1]), [3, i]))
				}
			}
	}
	return ((a.l.length = r), _.set(e, a), a)
}
function y(e) {
	let t = new Text(),
		n = new Text()
	return (e.parentNode.insertBefore(n, e.nextSibling), e.parentNode.insertBefore(t, n), { p: e.parentNode, v: t, $: n })
}
function b(e, t) {
	e.p.insertBefore(t, e.$)
}
function x(e) {
	let t = document.createDocumentFragment(),
		n = e.v.nextSibling
	for (; n !== e.$; ) {
		let e = n.nextSibling
		;(t.appendChild(n), (n = e))
	}
	return t
}
function S(e) {
	let t = e.v.nextSibling
	for (; t !== e.$; ) {
		let n = t.nextSibling
		;(e.p.removeChild(t), (t = n))
	}
}
function C(i, s = !0, c, l, u, d, p) {
	function m(e) {
		if (c && c !== e) {
			let e = a.get(c)
			e && (e.i.delete(m), e.i.size || (e.o.forEach(e => e?.()), (e.o.length = 0)))
		}
		c = e
	}
	function h() {
		if (u !== void 0) {
			for (let [, e] of u) e(null)
			;((l = void 0), (u = void 0))
		}
	}
	return function a(g) {
		if (n(g)) {
			if (!s && g === c) return
			;((s = !1), m(g))
			let t = g,
				i = o(t)
			;(i.i.size || (i.o = i.t.map(e => e())),
				i.i.set(m, () => {
					;((s = !0), a(t))
				}))
			try {
				g = t.render()
			} catch (t) {
				if (!e(t)) throw t
				g = t
			}
			n(g) && (g = r(g))
		} else m(void 0)
		if ((g === void 0 && (g = null), t(g))) {
			d || (h(), S(i), (d = []))
			let e = 0,
				t = i.v
			for (let n of g) {
				let r = f(n)
				if (d.length <= e) {
					let n = y(t)
					d[e] = { m: n, k: C(n), h: r }
				}
				if (r !== void 0 && d[e].h !== r) {
					for (let t = e + 1; t < d.length; t++) {
						let n = d[e],
							i = d[t]
						if (i.h === r) {
							let r = x(n.m)
							;(b(n.m, x(i.m)), b(i.m, r))
							let a = { ...n.m }
							;(Object.assign(n.m, i.m), Object.assign(i.m, a), (d[t] = n), (d[e] = i))
							break
						}
					}
					d[e].h = r
				}
				;(d[e].k(n), (t = d[e].m.$), e++)
			}
			for (; d.length > e; ) d.pop().k(null)
			return void (p = void 0)
		}
		if (d) {
			for (let e of d) e.k(null)
			d = void 0
		}
		if (e(g)) {
			let { T: e, N: t } = g,
				n = v(t)
			if (l !== n) {
				if (u !== void 0) {
					for (let [e, t] of u) t(null)
					u = void 0
				}
				let e = (l = n).u.cloneNode(!0),
					t = []
				for (let n of e.querySelectorAll(`[data-dynparts]`)) {
					let e = n.getAttribute(`data-dynparts`)
					n.removeAttribute(`data-dynparts`)
					for (let r of e.split(` `)) t[+r] = n
				}
				for (let e of l._) t[e] = i
				;(S(i),
					b(i, e),
					(u = n.l.map(([e, [n, r]], i) => {
						let a = t[i]
						switch (n) {
							case 0:
								let t
								if (a instanceof Node) t = a.childNodes[r]
								else {
									t = a.v.nextSibling
									for (let e = 0; e < r; e++) t = t.nextSibling
								}
								return [e, C({ p: t.parentNode, v: t.previousSibling, $: t.nextSibling })]
							case 1:
								return [e, E(a)]
							case 2:
								return [e, T(a, r)]
							case 3:
								return [e, w(a, r)]
						}
					})))
			}
			for (let [t, n] of u) n(e[t])
			return void (p = void 0)
		}
		Object.is(p, g) ||
			(h(),
			p == null || g === null || p instanceof Node || g instanceof Node
				? (S(i), g !== null && b(i, g instanceof Node ? g : new Text(`` + g)))
				: (i.v.nextSibling.data = `` + g),
			(p = g))
	}
}
function w(e, t) {
	return n => {
		e[t] = n
	}
}
function T(e, t) {
	return n => D(e, t, n)
}
function E(e) {
	let t
	return n => {
		;(t?.(), (t = n?.(e)))
	}
}
function D(e, t, n) {
	typeof n == `boolean` ? e.toggleAttribute(t, n) : n == null ? e.removeAttribute(t) : e.setAttribute(t, n)
}
function O(e, t) {
	return n => (D(n, e, t), () => D(n, e, null))
}
function k(e, t, n) {
	return r => (r.addEventListener(e, t, n), () => r.removeEventListener(e, t, n))
}
function A(e) {
	let t = (function (e) {
		let t = new Text(),
			n = new Text()
		return (e.appendChild(t), e.appendChild(n), { p: e, v: t, $: n })
	})(e)
	return { render: C(t) }
}
function j(e) {
	let t = 1,
		n = e
	for (; (n = n.nextSibling); )
		if (p(n)) {
			if (n.data === `?[`) t++
			else if (n.data === `?]` && (t--, t === 0)) return n
		}
	return null
}
function M(e, t) {
	let n
	for (n of e.childNodes) if (p(n) && n.data === `?[`) break
	let r = N({ p: e, v: n, $: j(n) }, t)
	return (r(t), { render: r })
}
function N(i, a) {
	let o, s, c, l
	if (n(a)) {
		try {
			a = (o = a).render()
		} catch (t) {
			if (!e(t)) throw t
			a = t
		}
		n(a) && (a = r(a))
	}
	if (t(a)) {
		l = []
		let { p: e } = i,
			t = i.v
		for (let n of a) {
			let r = f(n),
				i = t.nextSibling
			t = j(i)
			let a = { p: e, v: i, $: t }
			l.push({ m: a, k: N(a, n), h: r })
		}
	}
	if (e(a)) {
		s = v(a.N)
		let e = [],
			t = document.createTreeWalker(i.p, 129),
			n = document.createTreeWalker(s.u, 129)
		for (t.currentNode = i.v; t.nextNode() && n.nextNode(); ) {
			let r = t.currentNode,
				a = n.currentNode
			if (r === i.$) break
			if (p(r) && p(a)) {
				if (r.data === `?[`) {
					let e = j(r)
					t.currentNode = e
				}
			} else if (a.dataset.dynparts) for (let t of a.dataset.dynparts.split(` `)) e[+t] = r
		}
		for (let t of s._) e[t] = i
		c = s.l.map(([t, [n, r]], i) => {
			let o = e[i]
			switch (n) {
				case 0:
					let e
					if (o instanceof Node) e = o.childNodes[r]
					else {
						e = o.v.nextSibling
						for (let t = 0; t < r; t++) e = e.nextSibling
					}
					let n = j(e.previousSibling)
					return [t, N({ p: e.parentNode, v: e.previousSibling, $: n }, a.T[t])]
				case 1:
					return [t, E(o)]
				case 2:
					return [t, T(o, r)]
				case 3:
					return [t, w(o, r)]
			}
		})
	}
	return C(i, !0, o, s, c, l, a)
}
export { O as attr, A as createRoot, M as hydrate, c as invalidate, d as keyed, k as on, l as onMount, u as onUnmount }
