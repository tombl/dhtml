{"version":3,"file":"client.min.js","names":[],"sources":["../src/client/controller.ts","../src/client/util.ts","../src/client/compiler.ts","../src/client/span.ts","../src/client/parts.ts","../src/client/root.ts"],"sourcesContent":["import type { Displayable, Renderable } from '../index.ts'\nimport { assert, is_renderable } from '../shared.ts'\nimport { type Cleanup } from './util.ts'\n\nexport type Key = string | number | bigint | boolean | symbol | object | null\n\nexport interface Controller {\n\t_mount_callbacks: (() => Cleanup)[]\n\t_unmount_callbacks: Cleanup[]\n\t_invalidate: Map<object, () => void>\n}\n\nexport const controllers: WeakMap<Renderable, Controller> = new WeakMap()\n\nexport function get_controller(renderable: Renderable): Controller {\n\tlet controller = controllers.get(renderable)\n\tif (!controller)\n\t\tcontrollers.set(\n\t\t\trenderable,\n\t\t\t(controller = {\n\t\t\t\t_mount_callbacks: [],\n\t\t\t\t_unmount_callbacks: [],\n\t\t\t\t_invalidate: new Map(),\n\t\t\t}),\n\t\t)\n\treturn controller\n}\n\nconst keys: WeakMap<Displayable & object, Key> = new WeakMap()\n\nexport function invalidate(renderable: Renderable): void {\n\tconst controller = controllers.get(renderable)\n\tassert(controller, 'the renderable has not been rendered')\n\tcontroller._invalidate.forEach(invalidate => invalidate())\n}\n\nexport function onMount(renderable: Renderable, callback: () => Cleanup): void {\n\tassert(is_renderable(renderable), 'expected a renderable')\n\tconst controller = get_controller(renderable)\n\tif (controller._invalidate.size) {\n\t\tcontroller._unmount_callbacks.push(callback())\n\t} else {\n\t\tcontroller._mount_callbacks.push(callback)\n\t}\n}\n\nexport function onUnmount(renderable: Renderable, callback: () => void): void {\n\tonMount(renderable, () => callback)\n}\n\nexport function keyed<T extends Displayable & object>(displayable: T, key: Key): T {\n\tassert(!keys.has(displayable), 'renderable already has a key')\n\tkeys.set(displayable, key)\n\treturn displayable\n}\n\nexport function get_key(displayable: unknown): unknown {\n\t// the cast is fine because getting any non-object will return null\n\treturn keys.get(displayable as object) ?? displayable\n}\n","export type Cleanup = (() => void) | void | undefined | null\n\nexport function is_element(node: Node): node is Element {\n\treturn node.nodeType === (1 satisfies typeof Node.ELEMENT_NODE)\n}\n\nexport function is_comment(node: Node): node is Comment {\n\treturn node.nodeType === (8 satisfies typeof Node.COMMENT_NODE)\n}\n\nexport function is_document_fragment(node: Node): node is DocumentFragment {\n\treturn node.nodeType === (11 satisfies typeof Node.DOCUMENT_FRAGMENT_NODE)\n}\n","import { assert, lexer } from '../shared.ts'\nimport { is_comment, is_document_fragment, is_element } from './util.ts'\n\nexport const PART_CHILD = 0\nexport const PART_DIRECTIVE = 1\nexport const PART_ATTRIBUTE = 2\nexport const PART_PROPERTY = 3\n\nexport type PartData =\n\t| [type: typeof PART_CHILD, index: number]\n\t| [type: typeof PART_DIRECTIVE]\n\t| [type: typeof PART_ATTRIBUTE, name: string]\n\t| [type: typeof PART_PROPERTY, name: string]\n\nexport interface CompiledTemplate {\n\t_content: DocumentFragment\n\t_parts: [idx: number, PartData][]\n\t_root_parts: number[]\n}\n\nexport const DYNAMIC_WHOLE: RegExp = /^dyn-\\$(\\d+)\\$$/\nconst DYNAMIC_GLOBAL = /dyn-\\$(\\d+)\\$/g\nconst FORCE_ATTRIBUTES = /-|^class$|^for$/i\nconst NEEDS_UPPERCASING = /\\$./g\n\nconst templates: WeakMap<TemplateStringsArray, CompiledTemplate> = new WeakMap()\nexport function compile_template(statics: TemplateStringsArray): CompiledTemplate {\n\tconst cached = templates.get(statics)\n\tif (cached) return cached\n\n\tconst template_element = document.createElement('template')\n\tlet next_part = 0\n\ttemplate_element.innerHTML = [...lexer.lex(statics)]\n\t\t.map(([char, state]) => {\n\t\t\tif (char === '\\0') {\n\t\t\t\tif (state === lexer.DATA) return `<!--dyn-$${next_part++}$-->`\n\t\t\t\telse return `dyn-$${next_part++}$`\n\t\t\t}\n\t\t\tif (state === lexer.ATTR_NAME && char.toLowerCase() !== char) {\n\t\t\t\treturn `$${char}`\n\t\t\t}\n\t\t\treturn char\n\t\t})\n\t\t.join('')\n\n\tnext_part = 0\n\n\tconst compiled: CompiledTemplate = {\n\t\t_content: template_element.content,\n\t\t_parts: Array(statics.length - 1),\n\t\t_root_parts: [],\n\t}\n\n\tfunction patch(node: DocumentFragment | HTMLElement | SVGElement, idx: number, data: PartData) {\n\t\tassert(next_part < compiled._parts.length, 'got more parts than expected')\n\t\tif (is_document_fragment(node)) compiled._root_parts.push(next_part)\n\t\telse if ('dynparts' in node.dataset) node.dataset.dynparts += ' ' + next_part\n\t\t// @ts-expect-error -- this assigment will cast nextPart to a string\n\t\telse node.dataset.dynparts = next_part\n\t\tcompiled._parts[next_part++] = [idx, data]\n\t}\n\n\tconst walker = document.createTreeWalker(template_element.content, 129)\n\tassert((NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT) === 129)\n\n\twhile (walker.nextNode()) {\n\t\tconst node = walker.currentNode\n\t\tif (is_comment(node)) {\n\t\t\tconst match = DYNAMIC_WHOLE.exec(node.data)\n\t\t\tif (match !== null) {\n\t\t\t\tconst parent_node = node.parentNode\n\t\t\t\tassert(parent_node !== null, 'all text nodes should have a parent node')\n\t\t\t\tassert(\n\t\t\t\t\tparent_node instanceof DocumentFragment ||\n\t\t\t\t\t\tparent_node instanceof HTMLElement ||\n\t\t\t\t\t\tparent_node instanceof SVGElement,\n\t\t\t\t)\n\n\t\t\t\t// these will become the start and end of the span:\n\t\t\t\tparent_node.insertBefore(new Text(), node)\n\t\t\t\tparent_node.insertBefore(new Text(), node.nextSibling)\n\n\t\t\t\tpatch(parent_node, parseInt(match[1]), [PART_CHILD, [...parent_node.childNodes].indexOf(node)])\n\t\t\t}\n\t\t} else {\n\t\t\tassert(is_element(node))\n\t\t\tassert(node instanceof HTMLElement || node instanceof SVGElement)\n\n\t\t\tfor (const name of node.getAttributeNames()) {\n\t\t\t\tconst value = node.getAttribute(name)\n\t\t\t\tassert(value !== null)\n\n\t\t\t\tlet match = DYNAMIC_WHOLE.exec(name)\n\t\t\t\tif (match !== null) {\n\t\t\t\t\t// directive:\n\t\t\t\t\tnode.removeAttribute(name)\n\t\t\t\t\tassert(value === '', `directives must not have values`)\n\t\t\t\t\tpatch(node, parseInt(match[1]), [PART_DIRECTIVE])\n\t\t\t\t} else {\n\t\t\t\t\t// properties:\n\t\t\t\t\tmatch = DYNAMIC_WHOLE.exec(value)\n\t\t\t\t\tconst remapped_name = name.replace(NEEDS_UPPERCASING, match => match[1].toUpperCase())\n\t\t\t\t\tif (match !== null) {\n\t\t\t\t\t\tnode.removeAttribute(name)\n\t\t\t\t\t\tif (FORCE_ATTRIBUTES.test(remapped_name)) {\n\t\t\t\t\t\t\tpatch(node, parseInt(match[1]), [PART_ATTRIBUTE, remapped_name])\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpatch(node, parseInt(match[1]), [PART_PROPERTY, remapped_name])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (remapped_name !== name) {\n\t\t\t\t\t\tassert(!node.hasAttribute(remapped_name), `duplicate attribute ${remapped_name}`)\n\t\t\t\t\t\tnode.setAttribute(remapped_name, value)\n\t\t\t\t\t\tnode.removeAttribute(name)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(\n\t\t\t\t\t\t\t!DYNAMIC_GLOBAL.test(value),\n\t\t\t\t\t\t\t`expected a whole dynamic value for ${remapped_name}, got a partial one`,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcompiled._parts.length = next_part\n\n\ttemplates.set(statics, compiled)\n\treturn compiled\n}\n","import { assert } from '../shared.ts'\n\nexport interface Span {\n\treadonly _parent: Node\n\treadonly _start: Node\n\treadonly _end: Node\n}\n\nexport function create_span(node: Node): Span {\n\tassert(node.parentNode !== null)\n\tconst start = new Text()\n\tconst end = new Text()\n\n\tnode.parentNode.insertBefore(start, node)\n\tnode.parentNode.insertBefore(end, node.nextSibling)\n\n\treturn {\n\t\t_parent: node.parentNode,\n\t\t_start: start,\n\t\t_end: end,\n\t}\n}\n\nexport function create_span_into(parent: Node): Span {\n\tconst start = new Text()\n\tconst end = new Text()\n\n\tparent.appendChild(start)\n\tparent.appendChild(end)\n\n\treturn {\n\t\t_parent: parent,\n\t\t_start: start,\n\t\t_end: end,\n\t}\n}\n\nexport function create_span_after(node: Node): Span {\n\tassert(node.parentNode !== null)\n\tconst start = new Text()\n\tconst end = new Text()\n\n\tnode.parentNode.insertBefore(end, node.nextSibling)\n\tnode.parentNode.insertBefore(start, end)\n\n\treturn {\n\t\t_parent: node.parentNode,\n\t\t_start: start,\n\t\t_end: end,\n\t}\n}\n\nexport function insert_node(span: Span, node: Node): void {\n\tspan._parent.insertBefore(node, span._end)\n}\n\nexport function extract_contents(span: Span): DocumentFragment {\n\tconst fragment = document.createDocumentFragment()\n\n\tlet node = span._start.nextSibling\n\tfor (;;) {\n\t\tassert(node)\n\t\tif (node === span._end) break\n\t\tconst next = node.nextSibling\n\t\tfragment.appendChild(node)\n\t\tnode = next\n\t}\n\n\treturn fragment\n}\n\nexport function delete_contents(span: Span): void {\n\tlet node = span._start.nextSibling\n\tfor (;;) {\n\t\tassert(node)\n\t\tif (node === span._end) break\n\t\tconst next = node.nextSibling\n\t\tspan._parent.removeChild(node)\n\t\tnode = next\n\t}\n}\n","import {\n\tassert,\n\tis_html,\n\tis_iterable,\n\tis_renderable,\n\tsingle_part_template,\n\ttype Displayable,\n\ttype Renderable,\n} from '../shared.ts'\nimport {\n\tcompile_template,\n\tPART_ATTRIBUTE,\n\tPART_CHILD,\n\tPART_DIRECTIVE,\n\tPART_PROPERTY,\n\ttype CompiledTemplate,\n} from './compiler.ts'\nimport { controllers, get_controller, get_key, type Key } from './controller.ts'\nimport { create_span_after, delete_contents, extract_contents, insert_node, type Span } from './span.ts'\nimport type { Cleanup } from './util.ts'\n\nexport type Part = (value: unknown) => void\n\nexport function create_child_part(\n\tspan: Span,\n\n\t// for when we're rendering a renderable:\n\tneeds_revalidate = true,\n\tcurrent_renderable?: Renderable,\n\n\t// for when we're rendering a template:\n\told_template?: CompiledTemplate,\n\ttemplate_parts?: [number, Part][],\n\n\t// for when we're rendering multiple values:\n\tentries?: Array<{ _span: Span; _part: Part; _key: Key }>,\n\n\t// for when we're rendering a string/single dom node:\n\t// undefined means no previous value, because a user-specified undefined is remapped to null\n\told_value?: unknown,\n): Part {\n\tfunction switch_renderable(next: Renderable | undefined) {\n\t\tif (current_renderable && current_renderable !== next) {\n\t\t\tconst controller = controllers.get(current_renderable)\n\t\t\tif (controller) {\n\t\t\t\tcontroller._invalidate.delete(switch_renderable)\n\n\t\t\t\t// If this was the last instance, call unmount callbacks\n\t\t\t\tif (!controller._invalidate.size) {\n\t\t\t\t\tcontroller._unmount_callbacks.forEach(callback => callback?.())\n\t\t\t\t\tcontroller._unmount_callbacks.length = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcurrent_renderable = next\n\t}\n\n\tfunction disconnect_root() {\n\t\tif (template_parts !== undefined) {\n\t\t\tfor (const [, part] of template_parts) part(null)\n\t\t\told_template = undefined\n\t\t\ttemplate_parts = undefined\n\t\t}\n\t}\n\n\treturn function update(value) {\n\t\tif (is_renderable(value)) {\n\t\t\tif (!needs_revalidate && value === current_renderable) return\n\t\t\tneeds_revalidate = false\n\n\t\t\tswitch_renderable(value)\n\n\t\t\tconst renderable = value\n\t\t\tconst controller = get_controller(renderable)\n\t\t\t// If this is the first mounted instance, call mount callbacks\n\t\t\tif (!controller._invalidate.size) {\n\t\t\t\tcontroller._unmount_callbacks = controller._mount_callbacks.map(callback => callback())\n\t\t\t}\n\t\t\tcontroller._invalidate.set(switch_renderable, () => {\n\t\t\t\tassert(renderable === current_renderable)\n\t\t\t\tneeds_revalidate = true\n\t\t\t\tupdate(renderable)\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tvalue = renderable.render()\n\t\t\t} catch (thrown) {\n\t\t\t\tif (is_html(thrown)) {\n\t\t\t\t\tvalue = thrown\n\t\t\t\t} else {\n\t\t\t\t\tthrow thrown\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if render returned another renderable, we want to track/cache both renderables individually.\n\t\t\t// wrap it in a nested ChildPart so that each can be tracked without ChildPart having to handle multiple renderables.\n\t\t\tif (is_renderable(value)) value = single_part_template(value)\n\t\t} else switch_renderable(undefined)\n\n\t\t// if it's undefined, swap the value for null.\n\t\t// this means if the initial value is undefined,\n\t\t// it won't conflict with old_value's default of undefined,\n\t\t// so it'll still render.\n\t\tif (value === undefined) value = null\n\n\t\t// NOTE: we're explicitly not caching/diffing the value when it's an iterable,\n\t\t// given it can yield different values but have the same identity. (e.g. arrays)\n\t\tif (is_iterable(value)) {\n\t\t\tif (!entries) {\n\t\t\t\t// we previously rendered a single value, so we need to clear it.\n\t\t\t\tdisconnect_root()\n\t\t\t\tdelete_contents(span)\n\t\t\t\tentries = []\n\t\t\t}\n\n\t\t\t// create or update a root for every item.\n\t\t\tlet i = 0\n\t\t\tlet end = span._start\n\t\t\tfor (const item of value) {\n\t\t\t\tconst key = get_key(item) as Key\n\t\t\t\tif (entries.length <= i) {\n\t\t\t\t\tconst span = create_span_after(end)\n\t\t\t\t\tentries[i] = { _span: span, _part: create_child_part(span), _key: key }\n\t\t\t\t}\n\n\t\t\t\tif (key !== undefined && entries[i]._key !== key) {\n\t\t\t\t\tfor (let j = i + 1; j < entries.length; j++) {\n\t\t\t\t\t\tconst entry1 = entries[i]\n\t\t\t\t\t\tconst entry2 = entries[j]\n\n\t\t\t\t\t\tif (entry2._key === key) {\n\t\t\t\t\t\t\t// swap the contents of the spans\n\t\t\t\t\t\t\tconst tmp_content = extract_contents(entry1._span)\n\t\t\t\t\t\t\tinsert_node(entry1._span, extract_contents(entry2._span))\n\t\t\t\t\t\t\tinsert_node(entry2._span, tmp_content)\n\n\t\t\t\t\t\t\t// swap the spans back\n\t\t\t\t\t\t\tconst tmp_span = { ...entry1._span }\n\t\t\t\t\t\t\tObject.assign(entry1._span, entry2._span)\n\t\t\t\t\t\t\tObject.assign(entry2._span, tmp_span)\n\n\t\t\t\t\t\t\t// swap the roots\n\t\t\t\t\t\t\tentries[j] = entry1\n\t\t\t\t\t\t\tentries[i] = entry2\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tentries[i]._key = key\n\t\t\t\t}\n\n\t\t\t\tentries[i]._part(item as Displayable)\n\t\t\t\tend = entries[i]._span._end\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\t// and now remove excess parts if the iterable has shrunk.\n\t\t\twhile (entries.length > i) {\n\t\t\t\tconst entry = entries.pop()\n\t\t\t\tassert(entry)\n\t\t\t\tentry._part(null)\n\t\t\t}\n\n\t\t\told_value = undefined\n\t\t\treturn\n\t\t} else if (entries) {\n\t\t\tfor (const entry of entries) entry._part(null)\n\t\t\tentries = undefined\n\t\t}\n\n\t\tif (is_html(value)) {\n\t\t\tconst { _dynamics: dynamics, _statics: statics } = value\n\t\t\tconst template = compile_template(statics)\n\n\t\t\tassert(\n\t\t\t\ttemplate._parts.length === dynamics.length,\n\t\t\t\t'expected the same number of dynamics as parts. do you have a ${...} in an unsupported place?',\n\t\t\t)\n\n\t\t\tif (old_template !== template) {\n\t\t\t\tif (template_parts !== undefined) {\n\t\t\t\t\t// scan through all the parts of the previous tree, and clear any renderables.\n\t\t\t\t\tfor (const [_idx, part] of template_parts) part(null)\n\t\t\t\t\ttemplate_parts = undefined\n\t\t\t\t}\n\n\t\t\t\told_template = template\n\n\t\t\t\tconst doc = old_template._content.cloneNode(true) as DocumentFragment\n\n\t\t\t\tconst node_by_part: Array<Node | Span> = []\n\n\t\t\t\tfor (const node of doc.querySelectorAll('[data-dynparts]')) {\n\t\t\t\t\tconst parts = node.getAttribute('data-dynparts')\n\t\t\t\t\tassert(parts)\n\t\t\t\t\tnode.removeAttribute('data-dynparts')\n\t\t\t\t\tfor (const part of parts.split(' ')) node_by_part[+part] = node\n\t\t\t\t}\n\n\t\t\t\tfor (const part of old_template._root_parts) node_by_part[part] = span\n\n\t\t\t\t// the fragment must be inserted before the parts are constructed,\n\t\t\t\t// because they need to know their final location.\n\t\t\t\t// this also ensures that custom elements are upgraded before we do things\n\t\t\t\t// to them, like setting properties or attributes.\n\t\t\t\tdelete_contents(span)\n\t\t\t\tinsert_node(span, doc)\n\n\t\t\t\ttemplate_parts = template._parts.map(([dynamic_index, [type, data]], element_index): [number, Part] => {\n\t\t\t\t\tconst node = node_by_part[element_index]\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase PART_CHILD:\n\t\t\t\t\t\t\tlet child: ChildNode | null\n\n\t\t\t\t\t\t\tif (node instanceof Node) {\n\t\t\t\t\t\t\t\tchild = node.childNodes[data]\n\t\t\t\t\t\t\t\tassert(child)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchild = node._start.nextSibling\n\t\t\t\t\t\t\t\tassert(child)\n\t\t\t\t\t\t\t\tfor (let i = 0; i < data; i++) {\n\t\t\t\t\t\t\t\t\tchild = child.nextSibling\n\t\t\t\t\t\t\t\t\tassert(child !== null, 'expected more siblings')\n\t\t\t\t\t\t\t\t\tassert(child !== node._end, 'ran out of siblings before the end')\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tassert(child.parentNode && child.previousSibling && child.nextSibling)\n\n\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\tdynamic_index,\n\t\t\t\t\t\t\t\tcreate_child_part({\n\t\t\t\t\t\t\t\t\t_parent: child.parentNode,\n\t\t\t\t\t\t\t\t\t_start: child.previousSibling,\n\t\t\t\t\t\t\t\t\t_end: child.nextSibling,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\tcase PART_DIRECTIVE:\n\t\t\t\t\t\t\tassert(node instanceof Node)\n\t\t\t\t\t\t\treturn [dynamic_index, create_directive_part(node)]\n\t\t\t\t\t\tcase PART_ATTRIBUTE:\n\t\t\t\t\t\t\tassert(node instanceof Element)\n\t\t\t\t\t\t\treturn [dynamic_index, create_attribute_part(node, data)]\n\t\t\t\t\t\tcase PART_PROPERTY:\n\t\t\t\t\t\t\tassert(node instanceof Node)\n\t\t\t\t\t\t\treturn [dynamic_index, create_property_part(node, data)]\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tassert(template_parts)\n\t\t\tfor (const [idx, part] of template_parts) part(dynamics[idx])\n\n\t\t\told_value = undefined\n\t\t\treturn\n\t\t}\n\n\t\tif (!Object.is(old_value, value)) {\n\t\t\t// if we previously rendered a tree that might contain renderables,\n\t\t\t// and the template has changed (or we're not even rendering a template anymore),\n\t\t\t// we need to clear the old renderables.\n\t\t\tdisconnect_root()\n\n\t\t\tif (old_value != null && value !== null && !(old_value instanceof Node) && !(value instanceof Node)) {\n\t\t\t\t// we previously rendered a string, and we're rendering a string again.\n\t\t\t\tassert(span._start.nextSibling?.nextSibling === span._end && span._start.nextSibling instanceof Text)\n\t\t\t\tspan._start.nextSibling.data = '' + value\n\t\t\t} else {\n\t\t\t\tdelete_contents(span)\n\t\t\t\tif (value !== null) insert_node(span, value instanceof Node ? value : new Text('' + value))\n\t\t\t}\n\n\t\t\told_value = value\n\t\t}\n\t}\n}\n\nexport function create_property_part(node: Node, name: string): Part {\n\treturn value => {\n\t\t// @ts-expect-error\n\t\tnode[name] = value\n\t}\n}\n\nexport function create_attribute_part(node: Element, name: string): Part {\n\treturn value => set_attr(node, name, value)\n}\n\nexport type Directive = (el: Element) => Cleanup\n\nexport function create_directive_part(node: Node): Part {\n\tlet cleanup: Cleanup\n\treturn fn => {\n\t\tassert(typeof fn === 'function' || fn == null)\n\t\tcleanup?.()\n\t\tcleanup = fn?.(node)\n\t}\n}\n\nfunction set_attr(el: Element, name: string, value: unknown) {\n\tif (typeof value === 'boolean') el.toggleAttribute(name, value)\n\telse if (value == null) el.removeAttribute(name)\n\t// the cast is fine because setAttribute implicitly casts the value to a string\n\telse el.setAttribute(name, value as string)\n}\n\nexport function attr_directive(name: string, value: string | boolean | null | undefined): Directive {\n\treturn el => {\n\t\tset_attr(el, name, value)\n\t\treturn () => set_attr(el, name, null)\n\t}\n}\n\nexport function on_directive(\n\ttype: string,\n\tlistener: EventListenerOrEventListenerObject,\n\toptions?: boolean | AddEventListenerOptions,\n): Directive {\n\treturn el => {\n\t\tel.addEventListener(type, listener, options)\n\t\treturn () => el.removeEventListener(type, listener, options)\n\t}\n}\n","import { assert, is_html, is_iterable, is_renderable, single_part_template, type Displayable, type Renderable } from '../shared.ts'\nimport {\n\tcompile_template,\n\tDYNAMIC_WHOLE,\n\tPART_ATTRIBUTE,\n\tPART_CHILD,\n\tPART_DIRECTIVE,\n\tPART_PROPERTY,\n\ttype CompiledTemplate,\n} from './compiler.ts'\nimport { get_key, type Key } from './controller.ts'\nimport {\n\tcreate_attribute_part,\n\tcreate_child_part,\n\tcreate_directive_part,\n\tcreate_property_part,\n\ttype Part,\n} from './parts.ts'\nimport { create_span_into, type Span } from './span.ts'\nimport { is_comment, is_element } from './util.ts'\n\nexport interface Root {\n\trender(value: Displayable): void\n}\n\nexport function createRoot(parent: Node): Root {\n\tconst span = create_span_into(parent)\n\treturn { render: create_child_part(span) }\n}\n\nfunction find_end(start: Comment): Comment | null {\n\tassert(start.data === '?[')\n\tlet depth = 1\n\tlet node: ChildNode | null = start\n\twhile ((node = node.nextSibling)) {\n\t\tif (is_comment(node)) {\n\t\t\tif (node.data === '?[') depth++\n\t\t\telse if (node.data === '?]') {\n\t\t\t\tdepth--\n\t\t\t\tif (depth === 0) return node\n\t\t\t}\n\t\t}\n\t}\n\treturn null\n}\n\nexport function hydrate(parent: Node, value: Displayable): Root {\n\tlet start\n\tfor (start of parent.childNodes) {\n\t\tif (is_comment(start) && start.data === '?[') break\n\t}\n\tassert(\n\t\tstart && is_comment(start),\n\t\t`Could not find hydration start comment. Please ensure the element contains server-side rendered output.`,\n\t)\n\n\tconst end = find_end(start)\n\tassert(end, `Could not find hydration end comment. Please ensure the element contains server-side rendered output.`)\n\n\tconst render = hydrate_child_part({ _parent: parent, _start: start, _end: end }, value)\n\trender(value)\n\treturn { render }\n}\n\nfunction hydrate_child_part(span: Span, value: unknown) {\n\tlet current_renderable: Renderable | undefined\n\tlet template: CompiledTemplate | undefined\n\tlet template_parts: [number, Part][] | undefined\n\tlet entries: Array<{ _span: Span; _part: Part; _key: Key }> | undefined\n\n\tif (is_renderable(value)) {\n\t\ttry {\n\t\t\tvalue = (current_renderable = value).render()\n\t\t} catch (thrown) {\n\t\t\tif (is_html(thrown)) {\n\t\t\t\tvalue = thrown\n\t\t\t} else {\n\t\t\t\tthrow thrown\n\t\t\t}\n\t\t}\n\n\t\tif (is_renderable(value)) value = single_part_template(value)\n\t}\n\n\tif (is_iterable(value)) {\n\t\tentries = []\n\t\tconst { _parent } = span\n\t\tlet end = span._start\n\n\t\tfor (const item of value) {\n\t\t\tconst key = get_key(item) as Key\n\n\t\t\tconst start = end.nextSibling\n\t\t\tassert(start && is_comment(start) && start.data === '?[')\n\n\t\t\tend = find_end(start)!\n\t\t\tassert(end)\n\n\t\t\tconst span: Span = { _parent, _start: start, _end: end }\n\t\t\tentries.push({ _span: span, _part: hydrate_child_part(span, item), _key: key })\n\t\t}\n\t\tassert(end.nextSibling === span._end)\n\t}\n\n\tif (is_html(value)) {\n\t\ttemplate = compile_template(value._statics)\n\n\t\tconst node_by_part: Array<Node | Span> = []\n\n\t\tconst walker = document.createTreeWalker(span._parent, 129)\n\t\tconst template_walker = document.createTreeWalker(template._content, 129)\n\t\tassert((NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT) === 129)\n\t\twalker.currentNode = span._start\n\n\t\twhile (walker.nextNode() && template_walker.nextNode()) {\n\t\t\tconst node = walker.currentNode\n\t\t\tconst template_node = template_walker.currentNode\n\t\t\tif (node === span._end) break\n\n\t\t\tif (is_comment(node) && is_comment(template_node)) {\n\t\t\t\tif (node.data === '?[') {\n\t\t\t\t\tassert(DYNAMIC_WHOLE.test(template_node.data))\n\t\t\t\t\tconst end = find_end(node)\n\t\t\t\t\tassert(end)\n\t\t\t\t\twalker.currentNode = end\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tassert(is_element(node))\n\t\t\tassert(\n\t\t\t\tnode.nodeType === template_node.nodeType,\n\t\t\t\t`Node type mismatch: ${node.nodeType} != ${template_node.nodeType}`,\n\t\t\t)\n\t\t\tassert(template_node instanceof HTMLElement || template_node instanceof SVGElement)\n\t\t\tassert(node.tagName === template_node.tagName, `Tag name mismatch: ${node.tagName} !== ${template_node.tagName}`)\n\n\t\t\tif (template_node.dataset.dynparts)\n\t\t\t\tfor (const part of template_node.dataset.dynparts.split(' ')) node_by_part[+part] = node\n\t\t}\n\n\t\tfor (const part of template._root_parts) node_by_part[part] = span\n\n\t\ttemplate_parts = template._parts.map(([dynamic_index, [type, data]], element_index): [number, Part] => {\n\t\t\tconst node = node_by_part[element_index]\n\t\t\tswitch (type) {\n\t\t\t\tcase PART_CHILD:\n\t\t\t\t\tlet child: ChildNode | null\n\n\t\t\t\t\tif (node instanceof Node) {\n\t\t\t\t\t\tchild = node.childNodes[data]\n\t\t\t\t\t\tassert(child)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild = node._start.nextSibling\n\t\t\t\t\t\tassert(child)\n\t\t\t\t\t\tfor (let i = 0; i < data; i++) {\n\t\t\t\t\t\t\tchild = child.nextSibling\n\t\t\t\t\t\t\tassert(child !== null, 'expected more siblings')\n\t\t\t\t\t\t\tassert(child !== node._end, 'ran out of siblings before the end')\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tassert(child.parentNode)\n\t\t\t\t\tassert(child.previousSibling && is_comment(child.previousSibling) && child.previousSibling.data === '?[')\n\t\t\t\t\tconst end = find_end(child.previousSibling)\n\t\t\t\t\tassert(end)\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tdynamic_index,\n\t\t\t\t\t\thydrate_child_part(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_parent: child.parentNode,\n\t\t\t\t\t\t\t\t_start: child.previousSibling,\n\t\t\t\t\t\t\t\t_end: end,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue._dynamics[dynamic_index],\n\t\t\t\t\t\t),\n\t\t\t\t\t]\n\t\t\t\tcase PART_DIRECTIVE:\n\t\t\t\t\tassert(node instanceof Node)\n\t\t\t\t\treturn [dynamic_index, create_directive_part(node)]\n\t\t\t\tcase PART_ATTRIBUTE:\n\t\t\t\t\tassert(node instanceof Element)\n\t\t\t\t\treturn [dynamic_index, create_attribute_part(node, data)]\n\t\t\t\tcase PART_PROPERTY:\n\t\t\t\t\tassert(node instanceof Node)\n\t\t\t\t\treturn [dynamic_index, create_property_part(node, data)]\n\t\t\t}\n\t\t})\n\t}\n\n\treturn create_child_part(span, true, current_renderable, template, template_parts, entries, value)\n}\n"],"mappings":"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"}